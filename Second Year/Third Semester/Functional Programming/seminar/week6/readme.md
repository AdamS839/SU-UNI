# Упражнение 6 – Дървета, асоциативни списъци

## Двоични дървета
Използваме следната имплементаци на двоични дървета:
```scheme
(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      
(define (make-leaf root) (make-tree root empty-tree empty-tree))
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)
```
Примерно дърво:
```scheme

(define t (make-tree 5
                     (make-tree 1
                                (make-tree 4
                                           '()
                                           (make-leaf 13))
                                (make-leaf 3))
                     (make-tree 8
                                (make-tree 0
                                           (make-leaf 10)
                                           (make-leaf 9))
                                (make-leaf 11))))

```
### Задача 1
Да се напише функция `tree-member? x t`, която проверява дали даден елемент се съдържа в дълбок списък.
```scheme
(tree-member? 9 t); -> #t
(tree-member? 18 t); -> #f
```
### Задача 2

Да се напише функция `depth t`, която намира височината на дърво. Опитайте се да я решите с рекурсия, както и чрез `deep-foldr`.
```scheme
(depth t); -> 4
```

### Задача 3

Да се напише функция `count-leafs t`, която намира броя на листата на двоично дърво.
```scheme
(count-leafs t); -> 5
```

### Задача 4

Да се напише функция `traverse t`, която обхожда дървото ляво-корен-дясно и връща списък от елементите на дървото
```scheme
(traverse t) ; -> '(4 13 1 3 5 10 0 9 8 11)
```
### Задача 5

Да се напише функция `level k t`, която връща елементите на дървото на ниво `k`. Нека броенето започва от 0-ла, тоест коренът на дървото се намира на ниво 0.
 
```scheme
(level 1 t); -> (1 8)
(level 2 t) ; -> '(4 3 0 11)
(level 4 t2); -> ‘()
```
# Асоциативни списъци
```scheme
(define (make-assoc f l)
  (map (lambda (x)
         (cons x (f x))) l))

(define assoc-list (make-assoc (lambda (x) (* x x)) '(1 2 3 4 5)))
```

## Задача 6
Да се напише функция функция  `keys assoc-list`, която връща списък от всички ключове в асоциативен списък. Да се напише подобно функция  `values assoc-list`, но за стойностите в асоциативен списък.

```scheme
(keys assoc-list) ; -> '(1 2 3 4 5)
(values assoc-list) ; -> '(1 4 9 16 25)
```

## Задача 7
Да се напише функция `search k assoc-l`, приемаща ключ и асоциативен списък, която намира двойката ключ-стойност съответстваща на ключа `k` (ако има повече от един еднакви ключа, гледа само първият). Ако не съществува елемент с подадения ключ, функцията да върне `#f`.

```scheme
(search 3 assoc-list) ; -> ‘(3 . 9)
(search 6 assoc-list) ; -> #f
```
## Задача 8
Да се напише функция `delete k assoc-l`, приемаща ключ и асоциативен списък, която връща асоциативния списък с изтрити елементи, чиито ключове са `k`.

```scheme
(delete 3 assoc-list) ; -> '((1 . 1) (2 . 4) (4 . 16) (5 . 25))
(delete 6 assoc-list) ; -> '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25))
```
## Задача 9
Да се напише функция, приемаща ключ, стойност и асоциативен списък, която добавя двойката ключ-стойност в списъка, ако не съществува елемент с подадения ключ, а в противен случай променя стойността на съществуващия елемент с подадения ключ. Опитайте се да запазите реда на ключовете.

```scheme
(add-assoc 6 36 assoc-list) ; -> '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25) (6 . 36))
(add-assoc 4 36 assoc-list) ; -> '((1 . 1) (2 . 4) (3 . 9) (4 . 36) (5 . 25))
```

## Задача 10
Да се напише функция, която по подаден списък, връща асоциативен списък, където ключовете са елементите в списъка, а стойностите са броят пъти, в които се среща елементът в списъка.

```scheme
(histogram '(8 7 1 7 8 2 2 8 2 7 8 1)) ; -> '((8 . 4) (7 . 3) (1 . 2) (2 . 3))
```

# Потоци
```scheme
(define-syntax cons-stream
  (syntax-rules () ((cons-stream h t)
                    (cons h (delay t)))))

(define head car)
(define (tail s) (force (cdr s))) 
```

## Задача 11
Да се напише функция, която по подадено число `n` и поток, връща списък от първите `n` елемента на потока.

## Задача 12
Да се напише функция, която генерира безкраен поток от всички естествени числа.

```scheme
(take 10 nats) ; -> '(0 1 2 3 4 5 6 7 8 9)
```

## Задача 13
Да се напише функция `map-stream`, която е аналогът на `map`, но за потоци.

```scheme
(take 10 (map-stream (lambda (x) (* x x)) nats)) ; -> '(0 1 4 9 16 25 36 49 64 81)
```

## Задача 14
Да се напише функция, която генерира безкраен поток от числата на Фибоначи

```scheme
(take 10 fib) ; -> '(0 1 1 2 3 5 8 13 21 34)
```



