# Упражнение 4 – Списъци и функции от по-висок ред върху тях

## Предикатите `eq?`, `eqv?`, `equal?`
Имаме следното включване:  **`eq?` ⊂ `eqv?` ⊂ `equal?`** 

  - `eq?` =  еднакви обекти в паметта + **в зависимост от имплементацията и за атоми**

```
(eq? "a" "a") ; #t
(eq? 2.5 2.5) ; #t
(eq? (/ 5 2) (/ 5 2)) ; #f
(eq? '() '()) ; #t
(eq? (list 1 2) (list 1 2)) ; #f 
(eq? 1 1.0) ; #f
(eq? 0.5 (/ 1 2)) ; #f
(eq? (inexact->exact 0.5) (/ 1 2)) ; #f
```
 - `eqv?` =  `eq?` + атоми

```
(eqv? "a" "a") ; #t
(eqv? 2.5 2.5) ; #t
(eqv? (/ 5 2) (/ 5 2)) ; #t
(eqv? '() '()) ; #t
(eqv? (list 1 2) (list 1 2)) ; #f 
(eqv? 1 1.0) ; #f
(eqv? 0.5 (/ 1 2)) 
(eqv? (inexact->exact 0.5) (/ 1 2)) ; #t
```
 - `equal?` =  `eqv?` + списъци
```
(equal? "a" "a") ; #t
(equal? 2.5 2.5) ; #t
(equal? (/ 5 2) (/ 5 2)) ; #t
(equal? '() '()) ; #t
(equal? (list 1 2) (list 1 2)) ; #f 
(equal? 1 1.0) ; #f
(equal? 0.5 (/ 1 2)) ; #t
(equal? (inexact->exact 0.5) (/ 1 2)) ; #t
```
- `=` сравнение на числа
```
(= 1 1.0) ; #t
(= 0.5 (/ 1 2)) ; #t
(= "a" "a") ; грешка -> очаква число
```

Ако ще сравнявате числа използвайте `=`, защото работи за всички видове.
Ако ще сравнявате списъци използвайте `equal?`.

## Списъци

Припомнете си `length`, `reverse`, `map`, `filter`. Напишете свои версии на тези функции.

### Задача 1

Да се напише функция `at`, която приема списък и число `n`, и връща елемента на позиция `n` в списъка.

### Задaча 2
Да се напишат функциите `(take n lst)` и `(drop n lst)`, който съответно взимат или премахват първите n елемента на списък:
```
(take 3 '(1 2 3 4 5)) -> '(1 2 3)
(take 10 '(1 2 3 4 5)) -> '(1 2 3 4 5)
(drop 3 '(1 2 3 4 5)) -> '(4 5)
(drop 10 '(1 2 3 4 5)) -> '()
```

### Задача 3
Да се напише функция `(append lst1 lst2)`, която конкатенира два списъка

### Задача 4
Да се напишат функциите `(all? p? lst)` и `(any? p? lst)`, които проверяват съответно дали всички или някои елементи на даден списък изпълняват предиката `p?`:
```
(all? even? '(1 2 3 4 5)) -> #f
(any? even? '(1 2 3 4 5)) -> #t
(any? (lambda (x) (> x 10)) '(4 2 6 3 1)) -> #f
```
Как може да стане с `filter` или с `map`?

### Задача 5
Да се напише функция `(zipWith lst1 lst2)`, която приема два списъка и връща списък от наредени двойки от техните съответни елементи:

```
(zipWith + '(1 2 4) '(5 2 5)) -> '(6 4 9)
```

Как може да напишете функцията `zip`, като използвате `zipWith`?
```
(zip '(1 2 3 4) '(#t #f #f)) -> '((1 . #t) (2 . #f) (3 . #f))
```
А как може чрез `zip` да получите `zipWith`, използвайки `map` или `filter`?

### Задача 6
Да се напише функция `(sorted? lst)`, която проверява дали списък е сортиран в ненамаляващ ред.

## `foldr` и `foldl` -  като `accumulate`, но за списъци

```
(define (foldr operation null_value lst)
  (if (null? lst) null_value
      (operation (car lst)
          (foldr operation null_value (cdr lst)))))

(define (foldl operation null_value lst)
  (if (null? lst) null_value
      (foldl operation (operation null_value (car lst)) (cdr lst))))
```

### Задача 7
Да се напишат функциите `length`, `all?`, `any?`, `reverse` , `map`  и `filter` чрез **`foldr`** и **`foldl`**.


