# Упражнение 2 - Рекурсивни и итеративни процеси

Използвайте итеративни процеси при решаването на задачите.


### Задача 1
Напишете функция `fact`, която пресмята факториела на дадено естествено число `n`.
```
0! = 1
1! = 1
n! = n.(n-1)...2.1
```
Примитивна рекурсия:<br>
- време - `O(n)`
- памет - `O(n)`


Опашкова рекурсия:<br>
- време - `O(n)`
- памет - `O(1)`


### Задача 2
Напишете функция `fib`, която по дадено естествено число `n` връща `n`-тото число на Фибоначи. Редицата е дефинирана така:
```
    F(0) = 0
    F(1) = 1
    F(n) = F(n - 1) + F(n - 2)
```

С примитивна рекурсия - времето е `O(2^n)`.
С опашкова рекурсия - времето е `O(n)`.

#### Проверете разликата във времето нужно за изпълнение чрез функцията `time`!

```
> (time (fib 42))
cpu time: 16624 real time: 16599 gc time: 1439
267914296
> (time (fib-iter 42))
cpu time: 0 real time: 0 gc time: 0
267914296
```

`time` принтира резултатът на израза в терминала. Понякога това може да е дълго и нежелателно. Две решения:
Запазване на резултата от изпълнението в променлива, така не се показва в терминала, а стойностите може да се използват за после:
```
> (define results (time (fact 100)))
cpu time: 0 real time: 0 gc time: 0
> results
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```
Запазване на резултатът от изпълнението в променлива, но също така запазваме и времето за изпълнение - използваме `time-apply`:
```
> (time-apply fact (list 100))
'(93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000)
0
0
0
> (define-values (result user-time system-time real-time)
  (time-apply fact (list 100)))
> result
(93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000)
```
Използва list, което още не сме учили, но идеята е да се подадат аргументите на функцията, която изследваме като списък.
`time-apply` връща няколко резултата и всеки е на нов ред в REPL.

#### Тогава защо изобщо бихме използвали примитивна рекурсия, вместо опашкова (итерация)?

### Задача 3
Напишете функция `interval-sum`, която по дадени реални числа `a` и `b` пресмята сбора на целите числа в интервала `[a, b]`.

### Задача 4
Напишете функция `pow-i`, която за дадени цели числа x и n връща x^n.

### Задача 5
Напишете функция `(number-length n)`, която смята броя на цифрите на дадено естествено число.

### Задача 6
Напишете функция `(reverse-digits n)`, която обръща последователността на цифрите на дадено естествено число:
```
(reverse-digits 123) -> 321
(reverse-digits 10) -> 1 ; (!)
```

### Задача 7
Да се напише функция `(to-binary n)`, която превръща дадено естествено число в двоична бройна система:
```
(to-binary 8) -> 1000
(to-binary 15) -> 1111
(to-binary 42) -> 101010
```
### Задача 8
Да се напише функция `(to-decimal n)`, която превръща дадено естествено число от двоична в десетична бройна система:
```
(to-decimal 101010) -> 42
(to-decimal (to-binary 1234)) -> 1234

```
## Задача 9 
Напишете функция `(prime? n)`, която проверява дали числото `n` е просто.

### Пример:
```scheme
(prime? 1) ; -> #f
(prime? 21) ; -> #f
(prime? 37) ; -> #t
(prime? 739391) ; -> #t
