; pre problems

(define (foldr operation null_value lst)
  (if (null? lst) null_value
      (operation (car lst)
          (foldr operation null_value (cdr lst)))))

(define (foldl operation null_value lst)
  (if (null? lst) null_value
      (foldl operation (operation null_value (car lst)) (cdr lst))))

(define (>0? x) (> x 0))

(define (member? i lst)
  (cond ((null? lst) #f)
        ((equal? i (car lst)) #t)
        (else (member? i (cdr lst)))))


(define (^2 x) (* x x))
(define (succ x) (+ x 1))

; problem 00

(define (reverse-foldr lst)
  (foldr (lambda (i result) (append result (list i))) `() lst))

(define (reverse-foldl lst)
  (foldl (lambda (i result) (cons result i)) `() lst))

(define (map-foldr f lst)
  (foldr (lambda (i result) (cons (f i) result)) `() lst))

;(define (map-foldl f lst)
;  (foldl (lambda (i result) (cons )) `() lst))

(define (filter-foldr p? lst)
  (foldr (lambda (i result) (if (p? i) (cons i result) result)) `() lst))

; problem 01 - least

(define (least lst)
  (foldr (lambda (i result) (if (< i result) i result)) (car lst) lst))

; prolem 02 - unique

(define (unique lst)
  (foldr (lambda (i result) (if (member? i result) result (cons i result))) `() lst))

; problem 03 - union/intersection

(define (union l1 l2)
  (cond ((null? l1) l2)
        ((null? l2) l1)
        (else (unique (append (unique l1) (unique l2))))))

(define (intersection l1 l2)
  (cond ((null? l1) '())
        ((member (car l1) l2)
         (cons (car l1) (intersection (cdr l1) l2)))
        (else (intersection (cdr l1) l2))))

; ...

; problem 06 - interval

(define (find-interval . xs)
  (- (apply max xs) (apply min xs)))

; problem 07 - min lex

(define (min-lex-two a b)
  (if (string<? a b) a b))

(define (min-lex x . xs)
  (if (null? xs) x
      (min-lex-two x (apply min-lex xs))))

; problem 08 - compose all

(define (compose-all2 . f)
  (if (null? f) (lambda (x) x)
      (lambda (x) ((car f) ((apply compose-all2 (cdr f)) x)))))

; Дълбоки Списъци

(define dl '((1 2) ((3 (4) 5) (((6)))) (7)))

(define (atom? l)
  (and (not (null? l)) (not (pair? l))))

(define (deep-foldr op term nv l)
  (cond ((null? l) nv)
        ((atom? l) (term l))
        (else (op (deep-foldr op term nv (car l))
                  (deep-foldr op term nv (cdr l))))))

; problem 09 - deep-map

(define (deep-map f dl)
  (cond ((null? dl) `())
        ((atom? dl) (f dl))
        (else (cons (deep-map f (car dl)) (deep-map f (cdr dl))))))

;example: (deep-map (lambda (x) (* x x)) dl); -> '((1 4) ((9 (16) 25) (((36)))) (49))

; problem 10 - deep-filter ???????

(define (deep-filter p? dl)
  (cond ((null? dl) `())
        ((atom? dl) (if (p? dl) dl `()))
        (else (cons (deep-filter p? (car dl)) (deep-filter p? (cdr dl))))))
       
        
;example: (deep-filter even? dl); -> '((2) (((4)) (((6)))) ())

; problem 11 - deep-member?

(define (deep-member? x dl)
  (cond ((null? dl) #f)
        ((atom? dl) (equal? x dl))
        (else (or (deep-member? x (car dl)) (deep-member? x (cdr dl))))))

; Бинарни дървета

(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      
(define (make-leaf root) (make-tree root empty-tree empty-tree))
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)

(define t (make-tree 5
                     (make-tree 1
                                (make-tree 4
                                           '()
                                           (make-leaf 13))
                                (make-leaf 3))
                     (make-tree 8
                                (make-tree 0
                                           (make-leaf 10)
                                           (make-leaf 9))
                                (make-leaf 11))))

(define (tree-member? x t)
  (cond ((empty-tree? t) #f)
        (else (or (equal? x (root-tree t)) (tree-member? x (left-tree t)) (tree-member? x (right-tree t))))))

; problem 12 - depth

(define (depth t)
  (cond ((empty-tree? t) 0)
        ;((atom? t) 1)
        (else (+ 1 (max (depth (left-tree t))
                        (depth (right-tree t)))))))

(define (depth t)
  (cond ((empty-tree? t) 0)
        (else (+ 1 (max (depth (left-tree t))
                        (depth (right-tree t)))))))

(define (depth-foldr t)
  (deep-foldr (lambda (l r) (max (+ l 1) r)) (lambda (x) 0) 0 t))

;example: (depth t); -> 4

; problem 13 - count leaves

(define (count-leaves t)
  (cond ((empty-tree? t) 0)
        ((and (empty-tree? (left-tree t)) (empty-tree? (right-tree t))) 1)
        (else (+ (count-leaves (left-tree t)) (count-leaves (right-tree t))))))

;(count-leafs t); -> 5

; problem 14 - traverse

(define (traverse t)
  (cond ((empty-tree? t) `())
        (else (append (traverse (left-tree t)) (list (root-tree t)) (traverse (right-tree t))))))

;(traverse t) ; -> '(4 13 1 3 5 10 0 9 8 11)


; problem 15 - level

(define (level k t)
  (cond ((empty-tree? t) `())
        ((zero? k) (list (root-tree t)))
        (else (append (level (- k 1) (left-tree t)) (level (- k 1) (right-tree t))))))

;(level 1 t); -> (1 8)
;(level 2 t) ; -> '(4 3 0 11)
;(level 4 t2); -> ‘()






                             