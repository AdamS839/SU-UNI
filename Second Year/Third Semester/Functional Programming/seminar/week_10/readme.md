# Упражнение 10 - Лениво оценяване, безкрайни списъци, входно-изходни операции

Ленивото оценяване (call-by-need) се извършва чак когато даден израз е нужен. До тогава той се пази в паметта, като отложено оценяване. 
- Това може да доведе до прекалено голямо използване на памет
- Избягва се повторението чрез използването на общи подизрази
- Може да избегне ситуации, където изразът иначе не би се оценил (при апликативното оценяване на пример - там първо се оценяват аргументите)
```haskell
x = (2 + 5, error "Грешка")
> fst x – 7
f x = f x
l = 1:2:f 0:[]
> f 0 – не завършва, смята безкрайно
> take 2 l – завършва, оценява само първите два елемента 
```
## Пример - наредени двойки от естествени числа - изброимо безкрайно множество

```haskell
pairs = [ (x, y) | x <- [0..], y <- [0..] ]
> take 10 pairs – [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)]
– не можем да достъпим наредени двойки започващи с 1
pairs2 = [ (x, y) | x <- [0..], y <- [0..], z <- [0..], x + y == z ]
> take 10 pairs – [(0,0),
– забива, защото реда на вземане на елементи е следният
– x = 0; y=0; z=0
– x = 0; y=0; z=1
– x = 0; y=0; z=2
– и тн
pairs3 = [ (x, z - x) | z <- [0..], x <- [0..z] ]
– Вторият списък е краен, тоест z се сменя в някой момент
– Обхождаме всички възможни двойки без повторения, защото z представлява сумата на двете числа
```
Още един пример за реда на изпълнение. Вижда се, че първо въртим по `z`:
```haskell
pairs4 = [ (x, z) | x <- [0..], y <- [0..], z <- [0..], mod z 2 == y ]
> take 10 pairs 4 – [(0,0),(0,2),(0,4),(0,6),(0,8),(0,10),(0,12),(0,14),(0,16),(0,18)]
```
## Задача 1
Да се направи безкраен списък на всички Питагорови тройки - да са уникални до точност на умножение по число и пермутация *(взимаме само (3, 4, 5), но не и (6, 8, 10), (4, 3, 5), (5, 3, 4))*.
```haskell
ghci> take 5 pitagoreanTripples 
[(3,4,5),(5,12,13),(8,15,17),(7,24,25),(20,21,29)]
```
## Задача 2 
Да се напише функция, която по дадени два безкрайни списъка и двуместен предикат връща безкраен списък от двойки елементи от двата списъка изпълняващи предиката. *Подсказка: може да използвате операторът !! за вземане на елемент по индекс*
```haskell
ghci> take 10 (filterTupels (\ x y -> mod (x + y) 5 == 0) [0..] [0..])
[(0,0),(0,5),(1,4),(2,3),(3,2),(4,1),(5,0),(0,10),(1,9),(2,8)]
```

## Задача 3 - От миналия път
Да се напише функция, която връща приближение  на e^x чрез формула на Тейлър. Използвайте безкрайни списъци. *Подсказка: Може да вземете само част от безкрайния списък, тоест приближението да е с дадена точност*
![image](taylor.png)

```haskell
ghci> expTaylor 1
2.718281828459045
ghci> expTaylor 2
7.389056098930174
```

## Задача 4 
Да се напише функция, която имплементира zipWith, но за потоци.

```haskell
take 5 (streamZipWith (+)  [1..] [10, 20..])  -- => [11, 22, 33, 44, 55]
```
## Задача 5

Да се напише функция, която приема функция и връща поток от многократната композиция на функцията.
```haskell
composeF f = [f(x), f (f (x)), f (f (f (x))) ...] 
```

## Входно изходни операции

Входно изходните операции са нечисти, тоест включват в себе си странични ефекти. Използва се типът `IO a`, за да обозначим, че дадено действие има странични ефекти и може да върне стойност от тип `a`. 

```haskell
-- Четене от стандартния вход
getLine :: IO String          -- Чете ред от конзолата
getChar :: IO Char            -- Чете един символ
getContents :: IO String      -- Чете всичко до EOF

-- Писане на стандартния изход
putStr :: String -> IO ()     -- Извежда низ без нов ред
putStrLn :: String -> IO ()   -- Извежда низ с нов ред
print :: Show a => a -> IO () -- Извежда стойност (използва show)

-- Примери
putStrLn "Hello"              -- Извежда "Hello\n"
print 42                      -- Извежда "42\n"
print [1, 2, 3]               -- Извежда "[1,2,3]\n"
```

IO операциите се комбинират с `>>` (последователност без предаване на стойност) и `>>=` (bind - последователност с предаване на стойност).

```haskell
-- >> - изпълнява две IO операции последователно
putStrLn "First" >> putStrLn "Second"

-- >>= - предава резултата от първата операция към втората
getLine >>= \line -> putStrLn ("You entered: " ++ line)
```
## Главна функция main

Всяка Haskell програма, която иска да се изпълни, трябва да има функция `main` от тип `IO ()`. Това е входната точка на програмата.

```haskell
main :: IO ()
main = putStrLn "Hello, World!"
```
Можете да пуснете вашата програма по следните начини:
- Чрез компилиране и изпълнение
```bash
$ ghc ex_10.hs -o ex10
$ ./ex10
Hello, World!
```
- Чрез интерпретатора
```bash
$ ghci ex_10.hs
GHCi, version 9.6.7: https://www.haskell.org/ghc/  :? for help
[1 of 2] Compiling Main             ( ex_10.hs, interpreted )
Ok, one module loaded.
ghci> main
Hello, World!
```

### `do` нотацията е синтактична захар, която прави работата с IO операции по-четима. Тя позволява да пишем последователни IO операции по императивен начин.

```haskell
main = do
  действие1 -- Индентацията е от значение
  действие2
  променлива <- действие3  -- Резултатът се присвоява на променлива
  действие4 променлива
```

## Пример

```haskell
main :: IO ()
main = do
  putStrLn "Enter your name: " – Ако сложите само putStr,  текстът ще се покаже чак с последният putStrLn
  name <- getLine

  putStrLn "Enter your age: "
  ageLine <- getLine
  let age = read ageLine :: Int – `read` превръща полученият низ към желания тип. 

  putStrLn ("Hey, " ++ name ++ "! Next year you would be " ++ show (age + 1) ++ " years old!")
```

## Задача 6
Напишете програма, която приема произволен брой числа разделени с интервал и печата на екрана броят на приетите числа. *Подсказка: може да използвате splitBy от предишния път или вградената функция words*	

```haskell
ghci> main
Enter numbers
2 56 12.9 -9.2 2.0
There are 5 numbers.
```

## Задача 7

Напишете програма, която приема стринг и цяло число и печата на екрана стрингът повторен толкова пъти, колкото вкараното число.

```haskell
ghci> main
Enter string: 
asd
Enter number of times to repeat: 
9
asdasdasdasdasdasdasdasdasd
```
