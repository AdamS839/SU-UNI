; problem 00

(define id (lambda (x) x))
(define (next x) (+ x 1))
(define (prev x) (- x 1))
(define (square x) (* x x))

(define (5+ x) (+ x 5))
(define (3* x) (* x 3))
(define (compose f g) (lambda (x) (f (g x))))

; problem 01

(define (flip f) (lambda (x y) (f x y)))

; problem 02

(define (repeat f n) (lambda (x)
                       (define (cycle f rep x)
                         (if (zero? rep)
                             x
                             (cycle f (- rep 1) (f x))))
                       (cycle f n x)))

(define (repeat2 f n)
                     (if (= n 0)
                            (id x)
                            (lambda (x) (f ((repeat f (- n 1)) x)))))


; problem 03

;(define (twist k f g) ;k - четно
;  (lambda (x) (if (= (remainder k 2) 0) (repeat2 f ()
;                          (i

(define (twist k f g) ;k - четно
  (repeat (compose f g) (/ k 2)))

; problem 04

(define (curry f) (lambda (x) (lambda (y) (f x y))))

; Only use this function for all other

(define (accumulate operation null-value begin end term next)
  (if (> begin end) null-value
      (operation (term begin)
                 (accumulate operation null-value (next begin) end term next))))

; problem 05

(define (!! n) (accumulate * 1 (if (odd? n) 1 2) n id (lambda (x) (+ x 2))))

; problem 06

(define (sum-odd-squares a b) (accumulate + 0 (if (odd? a) a (next a)) (if (odd? b) b (prev b)) (lambda (x) (square x)) (lambda (x) (+ x 2))))

;problem 07


;(define (binomial n k) (accumulate * 1 1 k (lambda (x) (/ (- (+ 1 n) x) x)) ++))

(define (binomial n k)
  (accumulate * 1 1 k (lambda (x) (/ (- (+ 1 n) x) x)) next))

; problem 08

(define (argmax f a b) (accumulate (lambda (x y) (if (< (f x) (f y)) y x)) a a b id next))

; problem 9.1

(define (all? p? a b) (accumulate (lambda (x y) (and x y)) #t a b p? next))

; problem 9.2

(define (any? p? a b) (accumulate (lambda (x y) (or x y)) #t a b p? next))

; problem 10

(define (digits-count n) (if (zero? n) 1 (accumulate + 0 1 n (lambda (x) 1) (lambda (x) (* x 10)))))

; problem 11

(define (prime? n) (if (< n 2) #f (all? (lambda (x) (not (zero? (remainder n x)))) 2 (/ n 2))))

; problem 12

(define (repeat-acc f n) (accumulate compose id 1 n (lambda (x) f) next))

; problem 13

(define (twist-acc n f g) (accumulate compose id 1 n (lambda (x) (if (odd? x) g f)) next))