# Упражниение 13 - Алгебрични типове данни (продължение)


## Припомнете си следните типове:
- типът `List`, за който добавихме инстанции към класа `Show` и `Foldable`
```haskell
data List a
 = Nil
 | Cons a (List a)
 deriving (Show, Foldable)
```
- типът `Btree` за двоично дърво
```haskell
data BTree a
 = Leaf
 | Node a (BTree a) (BTree a)
   deriving (Eq, Foldable)

instance Show a => Show (BTree a) where
   show Leaf = ""
   show (Node x left right) = "(" ++ show x ++ show left ++ show right ++ ")"
```

## Класът `Functor`

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
    (<$) :: a -> f b -> f a
```

Тип данни `f a`, където можем да мапваме елементите на структурата, може да станат част от класа `Functor`. Идеята е, че можем да правим нови структури от тип `f b`, където променяме елементите, но запазваме самата структура на обекта. 

#### Например:
- Списъците са част от класа `Functor` - можем да вземем списък от числа и да върнем списък от стрингове - де факто `map` отговаря на `fmap`:
```haskell
ghci> fmap show [1, 3, 5, 2]
["1","3","5","2"]
ghci> [] <$ [1, 3, 5, 2]
[[],[],[],[]]
```

### Задача 1 
Да се инстанцира класа `Functor` за типа `List`.



#### Задача 2
Да се напише тип BST - наредено двоично дърво. Да се инстанцира класа `Functor` за типа BST.

Да се дефинират следните функции за него:
- `bstInsert :: Ord a => a -> BST a -> BST a` - добавяне на стойност в дървото
- `bstSearch :: Ord a => a -> BST a -> Bool`  - търсене на стойност в дървото
- `bstValues :: BST a -> [a]`                 - получаване на списък със всички стойности в дървото - може ли да е сортиран?
- `bstSize :: BST a -> Int`                   - брой стойности, съдържани в дървото
- `bstSort :: Ord a => [a] -> [a]`            - сортиране, използвайки `BST` като междинна структура


[Примерна имплементация на вмъкване на елемент](https://www.geeksforgeeks.org/dsa/insertion-in-binary-search-tree/)

### Задача 3
Да се дефинира тип `Map`, който да представлява структурата от данни асоциативен списък, реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:
- `mapInsert :: Ord k => k -> v -> Map k v -> Map k v` -- вмъкване на ключ със стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде заместена с новата.
- `mapSearch :: Ord k => k -> Map k v -> Maybe v`      -- търсене на стойност по ключ в дървото

Да се инстанцира класа `Functor` и за типа `Map`. _Подсказка_: Добра идея ли е да можем да променяме ключовете?

### Задача 4 
Да се напише функция, която приема асоциативен списък от тип `Map String Float`, която връща асоциативен списък, където на всеки ключ от оригиналния списък съответства булева стойност дали оригиналната съответстваща стойност е неотрицателно или отрицателно число.

### Задача 5 
Да се напише предикат, който проверява дали дадено двоично дърво (`BTree`) е симетрично около корена.  

### Задача 6
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение, деление или степенуване* на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` -- изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr`           -- изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.

### Задача 7
Да се напише функция `labelTree :: Eq a => BTree a -> BTree Int`, която заменя всеки елемент в дадено дърво с неговата поредност на срещане при ляво-корен-дясно обхождане на дървото:
```
    ┌──'c'──┐         ┌──3──┐
 ┌─'a'─┐   'b'  ->  ┌─2─┐   1
'b'   'a'           1   2

t :: Tree Char
t = Node 'c' (Node 'a' (Node 'b' Leaf Leaf)
                       (Node 'a' Leaf Leaf))
             (Node 'b' Leaf Leaf)
```
