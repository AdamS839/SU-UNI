Задачи за контролно 2 ПЪРВИ вариант
Изисквания за завършване

(!) При решаването на задачите можете да използвате всички класове от стандартната библиотека, които са ви познати. Очаква се коректно управление на динамичната памет там, където е необходимо. Упътване: преценете внимателно къде и дали е необходимо да се разработват контруктори, деструктори, и оператори за присвояване. 

 

Задача 1. Агрегаторите са обекти, с чиято помощ може да се получи обобщена информация за крайна редица от числа. Макар че са различни помежду си, всички те позволяват еднакви операции: добавяне на елемент към редицата и намиране на агрегирания резултат.

 

а) [5т.] Да се дефинира абстрактен клас Agregator, дефиниращ операциите:

 

    void add(double): добавяне на елемент към редицата

    double result() const: намиране на агрегирания резултат

 

б) Да се реализират три конкретни агрегатора:

 

    [10т.] Sum: намира сумата на елементите на редица

    [10т.] Avg: намира средното аритметично на елементите на редица

    [20т.] Foldr: инициализира се с двуместен оператор O: double ✕ double → double и намира стойността на 

a1 O a2 O … O ak 


за редицата a1,...,ak. Например, за оператора * (умножение), този агрегатор ще намери a1 * a2  * … * ak. При празна редица поведението на агрегатора е недефинирано.

 

в) [15 т.] Да се дефинира функция double reduce([подходящ тип] seq, [подходящ тип] agg), която агрегира редица от числа seq, преставена по избран от вас начин, и връща резултата.

 

Например:

 

Foldr *maxer = 

  new Foldr([](double a,double b)->double{return std::max(a,b);});

std::cout << reduce({-5,-5,5},maxer); //->5

std::cout << reduce({-5,-5,5},new Sum); //->-5

delete maxer;



Задача 2. Шаблонът VectorStream<T> позволява да се разглеждат елементите на вектор последователно, започвайки от първия, чрез оператора за вход от поток >>. 

 

Шаблонът да дава следните възможности:

 

    [5 т.] Конструиране чрез конкретен вектор

    [20 т.] Оператор за вход от поток >>. При изчерпване на елементите на вектор, операторът да връща последния му елемент. При празен вектор се връща случаен резултат.

    [5т.] Метод reset, която инициализира четенето на вектора от неговото начало

    [20 т.] Метод peek(), с чиято помощ може да се прегледа следващия елемент който ще бъде прочетен от >>, без четенето да преминава напред във вектора

 

Пример: следният фрагмент ще изведе числата “001230123”

 

VectorStream<int> s({0,1,2,3});

std::cout << s.peek();

int a, b, c ,d;

s >> a >> b >> c >> d; std::cout << a << b << c << d;

s.reset();

s >> a >> b >> c >> d; std::cout << a << b << c << d;
